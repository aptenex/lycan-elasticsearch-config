LocalDate cArrival = LocalDate.parse(params.arrivalDate);
LocalDate cDeparture = LocalDate.parse(params.departureDate);
int paramGuestCount = params.guests;
int nights = (int) ChronoUnit.DAYS.between(cArrival, cDeparture);

if (doc['pricing.los.base64Blob'].size() == 0) {
  return false;
}

String losBase64 = doc['pricing.los.base64Blob'].get(0).utf8ToString();
String[] records = /\n/.split(losBase64);

int currentClosestMatchDiff = 99;
String[] closestMatch;

for(int i = 0; i < records.length; i++) {
  String[] recordParts = /,/.split(records[i]);
  String recordDate = recordParts[0];
  // check if date matches
  if (recordDate == params.arrivalDate) {
    // We now need to match the guest count, if no match exists closest one that is greater than it
    int guestCount = Integer.parseInt(recordParts[1]);

    if (guestCount == paramGuestCount) {
      closestMatch = recordParts;
      currentClosestMatchDiff = 0;

      break;
    } else {
      // we need to get the diff 
      int guestDiff = guestCount - paramGuestCount; 

      if (guestDiff > 0 && guestDiff < currentClosestMatchDiff) {
        // Ok guest diff means this count is higher - so we can use it
        currentClosestMatchDiff = guestDiff;
        closestMatch = recordParts;
      }
    }

  }
}

// If we've reached this point and the closestMatch is still null then no available price was available
if (closestMatch === null) {
  return false;
}

// Else we can return the correct price
float fp = Float.parseFloat(closestMatch[nights + 1]);

return fp > 0 && fp >= params.minimumPrice && fp <= params.maximumPrice;
