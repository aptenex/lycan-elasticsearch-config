GET /lycan_main.lake_como_villas.properties_m3v4bi/_search
{
  "_source": false,
  "script_fields": {
    "availabilityFailures": {
      "script": {
        "source": """
              ArrayList stateList = new ArrayList();
              if (doc['unitAvailability.dateRange.startDate'].size() == 0 || doc['unitAvailability.configuration.availability.keyword'].size() == 0) {
                  stateList.add("UNIT_AVAILABILITY_NOT_FOUND");
                  return stateList;
              }
            
              // Get the difference in days between the arrival and departure
              LocalDate cArrival = LocalDate.parse(params.arrivalDate);
              LocalDate cDeparture = LocalDate.parse(params.departureDate);

              int nights = (int) ChronoUnit.DAYS.between(cArrival, cDeparture);

              // Get the difference in days between the arrival
              // and unitAvailability start date sequence

              LocalDate uaStart = doc['unitAvailability.dateRange.startDate'].value.toLocalDate();           

              int uaDiffDays = (int) ChronoUnit.DAYS.between(uaStart, cArrival);
              if (uaDiffDays < 0) {
                throw new Exception("Cannot run query against past dates");
              }

              String[] minStayList = /,/.split(doc['unitAvailability.configuration.minStay.keyword'].value);
              String[] maxStayList = /,/.split(doc['unitAvailability.configuration.maxStay.keyword'].value);
              char[] changeoverList = doc['unitAvailability.configuration.changeover.keyword'].value.toCharArray();

              // 1 = arrival, 2 = departure, 3 = both 0 = neither

              int arrivalIndex = uaDiffDays;
              int departureIndex = uaDiffDays + nights;

              // Lets get arrival and departure
              char arrival = changeoverList[arrivalIndex];
              char departure = changeoverList[departureIndex];

              if (!arrival.toString().equals("1") && !arrival.toString().equals("3")) {
                stateList.add("CHANGEOVER_ARRIVAL_NOT_SATISFIED");
              }

              if (!departure.toString().equals("2") &&! departure.toString().equals("3")) {
                stateList.add("CHANGEOVER_DEPARTURE_NOT_SATISFIED");
              }

              int minStay = Integer.parseInt(minStayList[arrivalIndex]);
              int maxStay = Integer.parseInt(maxStayList[departureIndex]);

              if (nights < minStay) {
                // We want to see if this minimum stay can be made valid by checking ahead on the availability string
                // Do this by adding the difference onto the nights and check if that is valid
                // We subtract one as the departure day can be a N, with removing that we can just check
                // for the existence of N
                int minStayDiff = minStay - nights;
                int futureNightsSequence = uaDiffDays + nights + minStayDiff;

                String as = doc['unitAvailability.configuration.availability.keyword'].value;
                if (uaDiffDays > as.length()) {
                  throw new Exception(as.length() + "");
                }

                String asSpliced = as.substring(uaDiffDays, futureNightsSequence).toString();

                if (asSpliced.indexOf('N') < 0) {
                  stateList.add("MINIMUM_STAY_NOT_SATISFIED_WITH_AVAILABILITY")
                } else {
                  stateList.add("MINIMUM_STAY_NOT_SATISFIED");
                }

              }

              if (nights > maxStay) {
                stateList.add("MAXIMUM_STAY_NOT_SATISFIED");
              }

              return stateList;
""",
        "lang": "painless",
        "params": {
          "arrivalDate": "2020-01-05",
          "departureDate": "2020-01-12"
        }
      }
    },
    "sequenceChecked": {
      "script": {
        "source": """
              if (doc['unitAvailability.dateRange.startDate'].size() == 0 || doc['unitAvailability.configuration.availability.keyword'].size() == 0) {
                  return ["UNIT_AVAILABILITY_NOT_FOUND"];
              }
            
              if (params['arrivalDate'] !== null && params['departureDate'] !== null) {
                // Get the difference in days between the arrival and departure
                LocalDate cArrival = LocalDate.parse(params.arrivalDate);
                LocalDate cDeparture = LocalDate.parse(params.departureDate);

                int nights = (int) ChronoUnit.DAYS.between(cArrival, cDeparture);

                // Get the difference in days between the arrival
                // and unitAvailability start date sequence

                LocalDate uaStart = doc['unitAvailability.dateRange.startDate'].value.toLocalDate();

                int uaDiffDays = (int) ChronoUnit.DAYS.between(uaStart, cArrival);
                if (uaDiffDays < 0) {
                  return false;
                }
                String as = doc['unitAvailability.configuration.availability.keyword'].value;

                if (uaDiffDays > as.length()) {
                  throw new Exception(as.length() + "");
                }

                int nightsSequence = (uaDiffDays + nights);

                String asSpliced = as.substring(uaDiffDays, nightsSequence).toString();

                return [
                  'AVAILABILITY_CHECK',
                  uaDiffDays,
                  nightsSequence,
                  nights,
                  asSpliced,
                  (asSpliced.indexOf('N') < 0)
                ];
              } else {
                // We are looking for consecutive nights within a date range, this is near identical to
                // the normal arrival/departure, except we splice out the whole range and then do a check
                // if a certain number of Y's exist in that string
                
                LocalDate rangeStart = LocalDate.parse(params.startDate);
                LocalDate rangeEnd = LocalDate.parse(params.endDate);
                
                LocalDate uaStart = doc['unitAvailability.dateRange.startDate'].value.toLocalDate();
                String as = doc['unitAvailability.configuration.availability.keyword'].value;
                
                int uaDiffDays = (int) ChronoUnit.DAYS.between(uaStart, rangeStart);
                
                if (uaDiffDays < 0) {
                  return false;
                }

                if (uaDiffDays > as.length()) {
                  throw new Exception(as.length() + "");
                }
                
                int nightsInRange = (int) ChronoUnit.DAYS.between(rangeStart, rangeEnd);

                int lengthToEnd = uaDiffDays + nightsInRange;

                String asSpliced = as.substring(uaDiffDays, lengthToEnd).toString();
                String nightsToString = '';
                
                for (int i = 0; i<params.nights; i++) {
                   nightsToString = nightsToString + 'Y';
                }
                
                return [
                  'NIGHTS_AVAILABLE_IN_RANGE',
                  uaDiffDays,
                  nightsInRange,
                  params.nights,
                  asSpliced,
                  nightsToString,
                 (asSpliced.indexOf(nightsToString) > 0)
                ];
              }
""",
        "lang": "painless",
        "params": {
          "arrivalDate": "2020-01-05",
          "departureDate": "2020-01-12"
        }
      }
    }
  },
  "query": {
    "bool": {
      "must": {
        "script": {
          "script": {
            "source": """
                          if (doc['unitAvailability.dateRange.startDate'].size() == 0 || doc['unitAvailability.configuration.availability.keyword'].size() == 0) {
                            return false;
                          }
                        
                          // Get the difference in days between the arrival and departure
                          LocalDate cArrival = LocalDate.parse(params.arrivalDate);
                          LocalDate cDeparture = LocalDate.parse(params.departureDate);

                          int nights = (int) ChronoUnit.DAYS.between(cArrival, cDeparture);

                          // Get the difference in days between the arrival
                          // and unitAvailability start date sequence

                          LocalDate uaStart = doc['unitAvailability.dateRange.startDate'].value.toLocalDate();

                          int uaDiffDays = (int) ChronoUnit.DAYS.between(uaStart, cArrival);
                          if (uaDiffDays < 0) {
                            return false;
                          }
                          String as = doc['unitAvailability.configuration.availability.keyword'].value;

                          if (uaDiffDays > as.length()) {
                            throw new Exception(as.length() + "");
                          }

                          int nightsSequence = (uaDiffDays + nights);

                          String asSpliced = as.substring(uaDiffDays, nightsSequence).toString();

                          return (asSpliced.indexOf('N') < 0);
""",
            "lang": "painless",
            "params": {
              "arrivalDate": "2020-01-05",
              "departureDate": "2020-01-12"
            }
          }
        }
      }
    }
  }
}
